// This code was generated by the Managed Package Parser Generator


using System;
using System.Collections.Generic;
using System.Text;
using Babel.ParserGenerator;
using Microsoft.VisualStudio.TextManager.Interop;
using System.Linq;

namespace Babel.Parser
{
public enum Tokens {
    error=1,EOF=2,LBRACE=3,RBRACE=4,LBRACK=5,RBRACK=6,QUOTE=7,QUASIQUOTE=8,
    UNQUOTE=9,UNQUOTESPLICING=10,VECTORLBRACE=11,DOT=12,BYTEVECTORLBRACE=13,UNSYNTAX=14,SYNTAX=15,UNSYNTAXSPLICING=16,
    QUASISYNTAX=17,IGNOREDATUM=18,SYMBOL=19,LITERAL=20,STRING=21,NUMBER=22,CHARACTER=23,LEX_WHITE=24,
    LEX_COMMENT=25,LEX_ERROR=26,FORM=27,SUBFORM=28,RECORD=29,PROCEDURE=30,LIBRARY=31,IMPORT=32,
    EXPORT=33,DEFINE=34,DEFINESYNTAX=35,DEFINECONDITIONTYPE=36,DEFINERECORDTYPE=37,DEFINEENUMERATION=38,MODULE=39};

public partial struct LexValue
#line 83 "Generated\parser.y"
			{
    public string str;
    internal object value;
    internal Cons list;
}
// Abstract base class for MPLEX scanners
public abstract class ScanBase : AScanner<LexValue,LexLocation> {
    protected abstract int CurrentSc { get; set; }
    //
    // Override the virtual EolState property if the scanner state is more
    // complicated then a simple copy of the current start state ordinal
    //
    public virtual int EolState { get { return CurrentSc; } set { CurrentSc = value; } }
}

public partial class Parser: ShiftReduceParser<LexValue, LexLocation>
{
#line 10 "Generated\parser.y"


ErrorHandler handler = null;
public void SetHandler(ErrorHandler hdlr) { handler = hdlr; }
internal void CallHdlr(string msg, LexLocation val)
{
    handler.AddError(msg, val.sLin, val.sCol, val.eCol - val.sCol);
}
internal TextSpan MkTSpan(LexLocation s) { return TextSpan(s.sLin, s.sCol, s.eLin, s.eCol); }

internal void Match(LexLocation lh, LexLocation rh) 
{
    DefineMatch(MkTSpan(lh), MkTSpan(rh)); 
}

public object result = null;
internal List<Identifier> ids = new List<Identifier>();
Cons _imports = null;
internal string imports 
{ 
  get 
  { 
    return string.Join(" ", Enum(_imports).Select(x => x.ToString()).ToArray()); 
  } 
}

static IEnumerable<object> Enum(Cons c)
{
  while (c != null)
  {
    yield return c.car;
    c = c.cdr as Cons;
  }
}


static readonly object Ignore = new object();

static Cons Last(Cons c)
{
  while (c.cdr != null)
  {
    c = c.cdr as Cons;
  }
  return c;
}

static Cons Append(Cons c, Cons t)
{
  if (c == null || c.car == Ignore)
  {
    return t;
  }
  if (t == null || t.car == Ignore)
  {
    return c;
  }
  Last(c).cdr = t;
  return c;
}

Identifier Add(Identifier id)
{
  ids.Add(id);
  return id;
}



 
    
  protected override void Initialize()
  {
    this.errToken = (int)Tokens.error;
    this.eofToken = (int)Tokens.EOF;

    states=new State[62];
    AddState(0,new State(-11,new int[]{-7,1,-1,3}));
    AddState(1,new State(new int[]{2,2}));
    AddState(2,new State(-1));
    AddState(3,new State(new int[]{2,4,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,5,-2,6,-9,21,-6,31,-5,41}));
    AddState(4,new State(-2));
    AddState(5,new State(-12));
    AddState(6,new State(-26));
    AddState(7,new State(new int[]{32,58,4,-11,3,-11,5,-11,7,-11,10,-11,8,-11,9,-11,15,-11,16,-11,17,-11,14,-11,19,-11,27,-11,30,-11,33,-11,31,-11,39,-11,28,-11,29,-11,21,-11,34,-11,35,-11,36,-11,38,-11,37,-11,22,-11,20,-11,23,-11,11,-11,13,-11,18,-11},new int[]{-1,8}));
    AddState(8,new State(new int[]{4,9,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,10,-2,6,-9,21,-6,31,-5,41}));
    AddState(9,new State(-3));
    AddState(10,new State(new int[]{12,11,4,-12,3,-12,5,-12,7,-12,10,-12,8,-12,9,-12,15,-12,16,-12,17,-12,14,-12,19,-12,27,-12,30,-12,33,-12,31,-12,39,-12,28,-12,29,-12,21,-12,34,-12,35,-12,36,-12,38,-12,37,-12,22,-12,20,-12,23,-12,11,-12,13,-12,18,-12}));
    AddState(11,new State(new int[]{3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,12,-2,6,-9,21,-6,31,-5,41}));
    AddState(12,new State(new int[]{4,13}));
    AddState(13,new State(-5));
    AddState(14,new State(-11,new int[]{-1,15}));
    AddState(15,new State(new int[]{6,16,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,17,-2,6,-9,21,-6,31,-5,41}));
    AddState(16,new State(-4));
    AddState(17,new State(new int[]{12,18,6,-12,3,-12,5,-12,7,-12,10,-12,8,-12,9,-12,15,-12,16,-12,17,-12,14,-12,19,-12,27,-12,30,-12,33,-12,31,-12,39,-12,28,-12,29,-12,21,-12,34,-12,35,-12,36,-12,38,-12,37,-12,22,-12,20,-12,23,-12,11,-12,13,-12,18,-12}));
    AddState(18,new State(new int[]{3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,19,-2,6,-9,21,-6,31,-5,41}));
    AddState(19,new State(new int[]{6,20}));
    AddState(20,new State(-6));
    AddState(21,new State(new int[]{3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,22,-2,6,-9,21,-6,31,-5,41}));
    AddState(22,new State(-8));
    AddState(23,new State(-36));
    AddState(24,new State(-37));
    AddState(25,new State(-38));
    AddState(26,new State(-39));
    AddState(27,new State(-40));
    AddState(28,new State(-41));
    AddState(29,new State(-42));
    AddState(30,new State(-43));
    AddState(31,new State(-27));
    AddState(32,new State(-13));
    AddState(33,new State(-14));
    AddState(34,new State(-15));
    AddState(35,new State(-16));
    AddState(36,new State(-17));
    AddState(37,new State(-18));
    AddState(38,new State(-19));
    AddState(39,new State(-20));
    AddState(40,new State(-28));
    AddState(41,new State(-29));
    AddState(42,new State(-21));
    AddState(43,new State(-22));
    AddState(44,new State(-23));
    AddState(45,new State(-24));
    AddState(46,new State(-25));
    AddState(47,new State(-30));
    AddState(48,new State(-31));
    AddState(49,new State(-32));
    AddState(50,new State(-11,new int[]{-1,51}));
    AddState(51,new State(new int[]{4,52,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,5,-2,6,-9,21,-6,31,-5,41}));
    AddState(52,new State(-33));
    AddState(53,new State(-11,new int[]{-1,54}));
    AddState(54,new State(new int[]{4,55,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,5,-2,6,-9,21,-6,31,-5,41}));
    AddState(55,new State(-34));
    AddState(56,new State(new int[]{3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30,19,32,27,33,30,34,33,35,31,36,39,37,28,38,29,39,21,40,34,42,35,43,36,44,38,45,37,46,22,47,20,48,23,49,11,50,13,53,18,56},new int[]{-4,57,-2,6,-9,21,-6,31,-5,41}));
    AddState(57,new State(-35));
    AddState(58,new State(-9,new int[]{-3,59}));
    AddState(59,new State(new int[]{4,60,3,7,5,14,7,23,10,24,8,25,9,26,15,27,16,28,17,29,14,30},new int[]{-2,61,-9,21}));
    AddState(60,new State(-7));
    AddState(61,new State(-10));

    rules=new Rule[44];
    rules[1]=new Rule(-8, new int[]{-7,2});
    rules[2]=new Rule(-7, new int[]{-1,2});
    rules[3]=new Rule(-2, new int[]{3,-1,4});
    rules[4]=new Rule(-2, new int[]{5,-1,6});
    rules[5]=new Rule(-2, new int[]{3,-1,-4,12,-4,4});
    rules[6]=new Rule(-2, new int[]{5,-1,-4,12,-4,6});
    rules[7]=new Rule(-2, new int[]{3,32,-3,4});
    rules[8]=new Rule(-2, new int[]{-9,-4});
    rules[9]=new Rule(-3, new int[]{});
    rules[10]=new Rule(-3, new int[]{-3,-2});
    rules[11]=new Rule(-1, new int[]{});
    rules[12]=new Rule(-1, new int[]{-1,-4});
    rules[13]=new Rule(-6, new int[]{19});
    rules[14]=new Rule(-6, new int[]{27});
    rules[15]=new Rule(-6, new int[]{30});
    rules[16]=new Rule(-6, new int[]{33});
    rules[17]=new Rule(-6, new int[]{31});
    rules[18]=new Rule(-6, new int[]{39});
    rules[19]=new Rule(-6, new int[]{28});
    rules[20]=new Rule(-6, new int[]{29});
    rules[21]=new Rule(-5, new int[]{34});
    rules[22]=new Rule(-5, new int[]{35});
    rules[23]=new Rule(-5, new int[]{36});
    rules[24]=new Rule(-5, new int[]{38});
    rules[25]=new Rule(-5, new int[]{37});
    rules[26]=new Rule(-4, new int[]{-2});
    rules[27]=new Rule(-4, new int[]{-6});
    rules[28]=new Rule(-4, new int[]{21});
    rules[29]=new Rule(-4, new int[]{-5});
    rules[30]=new Rule(-4, new int[]{22});
    rules[31]=new Rule(-4, new int[]{20});
    rules[32]=new Rule(-4, new int[]{23});
    rules[33]=new Rule(-4, new int[]{11,-1,4});
    rules[34]=new Rule(-4, new int[]{13,-1,4});
    rules[35]=new Rule(-4, new int[]{18,-4});
    rules[36]=new Rule(-9, new int[]{7});
    rules[37]=new Rule(-9, new int[]{10});
    rules[38]=new Rule(-9, new int[]{8});
    rules[39]=new Rule(-9, new int[]{9});
    rules[40]=new Rule(-9, new int[]{15});
    rules[41]=new Rule(-9, new int[]{16});
    rules[42]=new Rule(-9, new int[]{17});
    rules[43]=new Rule(-9, new int[]{14});

    nonTerminals = new string[] {"", "exprlist", "list", "lists", "expr", 
      "definesym", "symbol", "file", "$accept", "specexpr", };
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // file -> exprlist EOF 
#line 104 "Generated\parser.y"
			{ result = value_stack.array[value_stack.top-2].list; }
        break;
      case 3: // list -> LBRACE exprlist RBRACE 
#line 109 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-3], location_stack.array[location_stack.top-1]); yyval.list = value_stack.array[value_stack.top-2].list; }
        break;
      case 4: // list -> LBRACK exprlist RBRACK 
#line 110 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-3], location_stack.array[location_stack.top-1]); yyval.list = value_stack.array[value_stack.top-2].list; }
        break;
      case 5: // list -> LBRACE exprlist expr DOT expr RBRACE 
#line 111 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-6], location_stack.array[location_stack.top-1]); yyval.list = Append(value_stack.array[value_stack.top-5].list, new Cons(value_stack.array[value_stack.top-4].value,value_stack.array[value_stack.top-2].value));}
        break;
      case 6: // list -> LBRACK exprlist expr DOT expr RBRACK 
#line 112 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-6], location_stack.array[location_stack.top-1]); yyval.list = Append(value_stack.array[value_stack.top-5].list, new Cons(value_stack.array[value_stack.top-4].value,value_stack.array[value_stack.top-2].value));}
        break;
      case 7: // list -> LBRACE IMPORT lists RBRACE 
#line 113 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-4], location_stack.array[location_stack.top-1]); _imports = Append(_imports, value_stack.array[value_stack.top-2].list);}
        break;
      case 9: // lists -> 
#line 118 "Generated\parser.y"
			{ yyval.list = null; }
        break;
      case 10: // lists -> lists list 
#line 119 "Generated\parser.y"
			{ yyval.list = Append(value_stack.array[value_stack.top-2].list, new Cons(value_stack.array[value_stack.top-1].list)); }
        break;
      case 11: // exprlist -> 
#line 123 "Generated\parser.y"
			{ yyval.list = null; }
        break;
      case 12: // exprlist -> exprlist expr 
#line 124 "Generated\parser.y"
			{ yyval.list = Append(value_stack.array[value_stack.top-2].list, new Cons(value_stack.array[value_stack.top-1].value)); }
        break;
      case 26: // expr -> list 
#line 148 "Generated\parser.y"
			{ yyval.value = value_stack.array[value_stack.top-1].list;}
        break;
      case 27: // expr -> symbol 
#line 149 "Generated\parser.y"
			{ yyval.value = Add(new Identifier(value_stack.array[value_stack.top-1].str) {Location = MkTSpan(location_stack.array[location_stack.top-1])}); }
        break;
      case 29: // expr -> definesym 
#line 151 "Generated\parser.y"
			{ yyval.value = new DefineLocation(value_stack.array[value_stack.top-1].str) {Location = MkTSpan(location_stack.array[location_stack.top-1])}; Add(new Identifier(value_stack.array[value_stack.top-1].str) {Location = MkTSpan(location_stack.array[location_stack.top-1])}); }
        break;
      case 30: // expr -> NUMBER 
#line 152 "Generated\parser.y"
			{ yyval.value = new Number(value_stack.array[value_stack.top-1].str); }
        break;
      case 33: // expr -> VECTORLBRACE exprlist RBRACE 
#line 155 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-3], location_stack.array[location_stack.top-1]); }
        break;
      case 34: // expr -> BYTEVECTORLBRACE exprlist RBRACE 
#line 156 "Generated\parser.y"
			{ Match(location_stack.array[location_stack.top-3], location_stack.array[location_stack.top-1]); }
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (((Tokens)terminal).ToString() != terminal.ToString())
      return ((Tokens)terminal).ToString();
    else
      return CharToString((char)terminal);
  }

#line 172 "Generated\parser.y"




}
}
